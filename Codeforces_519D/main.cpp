/**
ЗАДАНИЕ:
  A и B готовятся к олимпиадам про программированию.
  После нескольких лет занятия спортивным программированием и решения множества задач, требующих подсчета различных абстрактных объектов, у A и B тоже
  сложились весьма необычные вкусы.
  A увлечен строчными буквами латинского алфавита. Он присвоил каждой из них число, обозначающее насколько сильно она ему нравится (буквам, которые он
  недолюбливает, он присвоил отрицательное число).
  B увлечен подстроками. Особенно его интересуют те из них, которые начинаются и заканчиваются на одну и ту же букву (разумеется, в таком случае их длина
  должна быть больше единицы).
  У A и B также есть строка s. Теперь они пытаются выяснить, сколько подстрок t в s интересны для B (то есть t начинается и заканчивается на одну и ту же
  букву и имеет длину больше единицы) и при этом сумма значений всех букв (присвоенных A) в t, кроме первой и последней, равна нулю.
  Разумеется, A и B быстро нашли количество интересующих их подстрок t. А сможете ли это сделать вы?

ВВОД:
  Первая строка содержит 26 целых чисел xa, xb, ..., xz (-10^5 <= xi <= 10^5) - значение, присвоенное А буквам a, b, c, ..., z соответственно.
  Вторая строка содержит строку s длиной от 1 до 10^5 символов и состоящую из строчных букв латинского алфавита, для которой требуется посчитать ответ.

ВЫВОД:
  В единственной строке выходных данных выведите ответ на задачу.
*/

#include "iostream"
#include "vector"
#include "map"
#include "cstring"

#define SYM 26

using namespace std;

int main()
{
  int iNumDig[SYM], iWordLen;
  long long iAnswer = 0;
  vector<int> vecNumPos[SYM];
  string sWord;
  map<long long, int> mapCounter;

  for(int i = 0; i < SYM; ++i)
    cin >> iNumDig[i];
  cin >> sWord;

  iWordLen = sWord.size();
  vector<long long> vecSum(iWordLen);

  for(int i = 0; i < iWordLen; ++i)
  {
    if(i)
      vecSum[i] = iNumDig[sWord[i]-'a'] + vecSum[i-1];
    else
      vecSum[i] = 0;
    vecNumPos[sWord[i]-'a'].push_back(i);
  }

  for(int i = 0; i < SYM; ++i)
  {
    for(auto node : vecNumPos[i])
    {
      iAnswer += mapCounter[vecSum[node-1]];
      mapCounter[vecSum[node]]++;
    }
    mapCounter.clear();
  }

  cout << iAnswer;

  return 0;
}
