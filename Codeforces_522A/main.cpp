/**
ЗАДАНИЕ:
  Однажды Поликарп опубликовал в социальной сети смешную картинку с опросом про цвет своего хэндла. Многие из его друзей стали репостить шутку Поликарпа
  себе в ленту. Некоторые из них репостили репосты и так далее.
  Эти события заданы в виде последовательности строк "name1 reposted name2" где name1 - это имя того, кто репостнул, а name2 - имя того, с чей ленты
  репостнули шутку. Гарантируется, что для каждой строки "name1 reposted name2" пользователь "name1" еще не имел эту шутку в свой ленте, а "name2" уже
  имел ее в своей ленте к моменту репоста. Поликарп зарегистрирован под именем "Polycarp", и изначально шутка есть только в его ленте.
  Поликарп измеряет успешность шутки как длину наибольшей цепочки репостов. Выведите успешность шутки Поликарпа.

ВВОД:
  В первой строке входных данных записано целое число n (1 <= n <= 200) - количество репостов. Далее записаны сами репосты в порядке их совершения.
  Каждый из них записан в отдельной строке и имеет вид "name1 reposted name2". Все имена во входных данных состоят из прописных или строчных латинских букв
  и/или цифр и имеют длины от 2 до 24 символов включительно.
  Известно, что имена пользователей регистронезависимы, то есть два имени, отличающиеся исключительно регистром букв, соответствуют одному и тому же
  пользователю соцсети.

ВЫВОД:
  Выведите единственное целое число - максимальную длину цепочки репостов.
*/

#include "iostream"
#include "cstring"
#include "unordered_map"
#include "algorithm"
#include "array"

using namespace std;

int main()
{
  string first, second, repeted;
  unordered_map<string, int> mapCounter;
  int n, iMax(0);
  cin >> n;
  mapCounter["polycarp"] = 1;
  for(int i = 0; i < n; ++i)
  {
    cin >> first >> repeted >> second;
    transform(first.begin(), first.end(), first.begin(), ::tolower);
    transform(second.begin(), second.end(), second.begin(), ::tolower);
    mapCounter[first] = mapCounter[second] + 1;
    iMax = max(mapCounter[second], iMax);
  }

  cout << iMax + 1;

  return 0;
}
