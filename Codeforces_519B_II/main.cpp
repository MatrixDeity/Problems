/**
ЗАДАНИЕ:
  A и B готовятся к олимпиадам про программированию.
  B очень любит отлаживать свой код. Но перед тем, как запустить решение и начать отладку, код нужно сначала скомпилировать.
  Изначально компилятор выдавал n ошибок компиляции, каждая из которых обозначается положительным целым числом. После некоторых усилий, B удалось исправить
  сначала одну, а потом еще одну ошибку.
  Однако, несмотря на то, что B уверен, что исправил две ошибки, он не может понять, какие именно ошибки компиляции исчезли - компилятор языка, на котором
  пишет B, каждый раз выдает ошибки в новом порядке! B уверен, что в отличие от многих других языков программирования, ошибки компиляции для его языка
  программирования не зависят друг от друга, т. е. от исправления одной ошибки, множество остальных ошибок не изменяется.
  А вы можете помочь B узнать, какие именно две ошибки он исправил?

ВВОД:
  Первая строка входных данных содержит целое число n (3 <= n <= 10^5) - изначальное количество ошибок компиляции.
  Вторая строка содержит n целых чисел через пробел a1, a2, ..., an (1 <= ai <= 10^9) - номера ошибок, выданных компилятором в первый раз.
  Третья строка содержит n-1 целых чисел через пробел b1, b2, ..., bn-1 - номера ошибок, выданных при второй компиляции. Гарантируется, что
  последовательность в третьей строке содержит все числа второй строки, за исключением ровно одного.
  Четвертая строка содержит n-2 целых чисел через пробел с1, с2, ..., сn-2 - номера ошибок, выданных при третьей компиляции. Гарантируется, что
  последовательность в четвертой строке содержит все числа третьей строки, за исключением ровно одного.

ВЫВОД:
  Выведите два числа на отдельной строке: номера ошибок компиляции, исчезнувших после того как B внёс первое и второе исправление соответственно.
*/

#include "iostream"
#include "map"

using namespace std;

typedef unsigned long long u64;

int main()
{
  map<u64, u64> uMap1, uMap2, uMap3, uMapTemp;
  u64 count, k;
  cin >> count;
  for(u64 i = 0; i < count; i++)
  {
    cin >> k;
    uMap1[k]++;
  }

  for(u64 i = 0; i < count-1; i++)
  {
    cin >> k;
    uMap2[k]++;
  }

  for(u64 i = 0; i < count-2; i++)
  {
    cin >> k;
    uMap3[k]++;
  }

  for(auto mapNode : uMap1)
    if(mapNode.second != uMap2[mapNode.first])
    {
      cout << mapNode.first << endl;
      break;
    }

  for(auto mapNode : uMap2)
    if(mapNode.second != uMap3[mapNode.first])
    {
      cout << mapNode.first << endl;
      break;
    }

  return 0;
}
