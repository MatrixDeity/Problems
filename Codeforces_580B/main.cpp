/**
ЗАДАНИЕ:
  Кефа хочет отметить свой первый крупный заработок походом в ресторан. Однако ему нужна компания.
  У Кефы есть n друзей, каждый из которых согласится пойти в ресторан, если Кефа попросит. Каждый друг характеризуется количеством денег у него и степенью
  дружбы с Кефой. Наш попугай не хочет, чтобы какой-то друг почувствовал себя бедным по сравнению с кем-то другим в компании (Кефа не в счет). Друг
  чувствует себя бедным, если в компании есть кто-то, у кого денег хотя бы на d единиц больше, чем у него. Также Кефа хочет, чтобы суммарная степень дружбы
  членов компании была максимальной. Помогите ему пригласить оптимальную компанию!

ВВОД:
  Первая строка ввода содержит два целых числа, разделенных пробелом, n и d (1 <= n <= 10^5, ) - количество друзей у Кефы и минимальная разница денег,
  приводящая к тому, что человек чувствует себя бедным.
  В последующих n строках даны описания друзей Кефы, в (i+1)-й строке содержится описание i-го друга вида mi, si (0 <= mi, si <= 10^9) - количество денег
  и степень дружбы с Кефой соответственно.

ВЫВОД:
  Выведите максимальную суммарную степень дружбы, которой можно добиться.
*/

#include <stdio.h>
#include <cmath>
#include <algorithm>
#include <map>

using namespace std;

typedef long long s64;

const s64 N = 100000;

int main()
{
    pair<s64, s64> arr[N];
    s64 sum(0), result(0);
    s64 n, d;

	scanf("%I64i%I64i", &n, &d);
	for (s64 i = 0; i < n; ++i)
	    scanf("%I64i%I64i", &arr[i].first, &arr[i].second);

	sort(arr, arr + n);
	for (s64 l(0), r(0); l < n; ++l)
	{
		while (r < n && abs(arr[l].first - arr[r].first) < d)
        {
            sum += arr[r].second;
            ++r;
        }
		result = max(result, sum);
        sum -= arr[l].second;
	}

	printf("%I64i", result);
	return 0;
}
