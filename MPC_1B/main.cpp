/**
ЗАДАНИЕ:
  Шифровальной решёткой называется бумажный квадрат размера 4*4 клетки, в котором вырезаны четыре клетки-окошка. Наложив решётку на листок бумаги, имеющий
  такой же размер, пишут в её окошках первые четыре символа пароля (см. рисунок). После этого решётку поворачивают по часовой стрелке на 90 градусов. При
  таком расположении все ранее написанные буквы оказываются под решёткой, а в окошках появляется чистая бумага. Далее в окошках записываются следующие
  четыре символа пароля, после чего вновь поворачивает решётку на 90 градусов. Записав очередные четыре символа, делается ещё один поворот решётки и после
  этого пишут последние четыре символа пароля. Теперь, не имея такой же шифровальной решётки, очень трудно восстановить пароль по получившемуся квадрату с
  16 символами. Таким образом, можно быть уверенным в невозможности взломать пароль.
  Предположим, в Ваши руки попала решётка, которой пользовался человек, желающий зашифровать свой пароль, и получившийся в результате шифрования квадрат с
  16 символами. Ваша задача - расшифровать пароль.

ВВОД:
  В первых четырёх строках дана шифровальная решётка. Окошки в ней обозначены символами "X", а бумага - символами "." (символы разделены пробелами).
  Положение этой решётки соответствует тому положению, с которого начинается расшифровка пароля. Гарантируется, что данная решётка корректна, то есть в
  процессе шифрования в окошках всегда будут появляться клетки, в которых ещё ничего не записано. Кроме того, известно, что решётка связна, то есть является
  одним куском бумаги.
  В следующих четырёх строках дан квадрат с зашифрованным паролем. Все записанные в квадрате символы - строчные и прописные латинские буквы. Символы с
  зашифрованным паролем также введены построчно через пробел.

ВЫВОД:
  Выведите строку длиной 16 символов - исходный пароль.
*/


#include <iostream>

using namespace std;

const int N = 4;

string ans;
bool holes[N][N];
char letters[N][N];
char c;

int main()
{
    for (int i = 0; i < N; ++i)
        for (int j = 0; j < N;)
        {
            cin >> c;
            if (c == 'X')
                holes[i][j++] = true;
            else if (c == '.')
                holes[i][j++] = false;
        }
    for (int i = 0; i < N; ++i)
        for (int j = 0; j < N;)
        {
            cin >> c;
            if (c != ' ')
                letters[i][j++] = c;
        }

    for (int k = 0; k < 4; ++k)
    {
        for (int i = 0; i < N; ++i)
            for (int j = 0; j < N; ++j)
                if (holes[i][j])
                    ans.push_back(letters[i][j]);
        for (int i = 0; i < N / 2; ++i)
            for (int j = i; j < N-i-1; ++j)
            {
                bool temp = holes[i][j];
                holes[i][j] = holes[N-j-1][i];
                holes[N-j-1][i] = holes[N-i-1][N-j-1];
                holes[N-i-1][N-j-1] = holes[j][N-i-1];
                holes[j][N-i-1] = temp;
            }
    }
    cout << ans;
    return 0;
}

/*
. . . .
X . . X
. X . .
. . . X
P w o o
K h a a
s m r s
o d b k
*/
