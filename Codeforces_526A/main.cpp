/**
ЗАДАНИЕ:
  В новой игре от компании ZeptoLab "King of Thieves" вам предстоит, управляя своим персонажем, добраться до сундука с золотом, избегая ловушек и
  препятствий, расставленных на пути.
  Интересной особенностью игры является возможность проектирования собственных уровней, которые будут доступны для прохождения другим игрокам. Рассмотрим
  следующую модель простого уровня.
  Подземелье состоит из n участков, расположенных на одном вертикальном уровне, каждый из которых представляет из себя либо площадку, на которой может
  находиться персонаж, либо яму, падение в которую приводит к проигрышу. Все участки имеют одинаковую длину, площадки на схеме уровня изображаются как '*',
  а ямы - как '.'.
  На возможность скоростного прохождения уровня влияет возможность делать подряд множество прыжков одинаковой длины. Более формально, находясь на площадке
  номер i1, персонаж может сделать последовательность прыжков по площадкам i1 < i2 <...< ik, если i2-i1 = i3-i2 = ... = ik-ik-1. Разумеется, все участки i1,
  i2, ..., ik должны быть именно площадками, а не ямами.
  Уровень считается хорошим, если в нём можно произвести последовательность из четырёх прыжков одинаковой длины, или, иными словами, должна существовать
  последовательность i1, i2, ..., i5, состоящая из пяти площадок, расположенных через равные промежутки. По данной схеме уровня проверьте, является ли он
  хорошим.

ВВОД:
  В первой строке расположено целое число n (1 <= n <= 100) - количество участков на уровне.
  В единственной строке расположена схема уровня, представляющая собой строку из n символов '*' и '.'.

ВЫВОД:
  Если уровень является хорошим, то выведите ещё слово "yes" (без кавычек), иначе, выведите слово "no" (без кавычек).
*/

#include "iostream"
#include "unordered_set"

using namespace std;

int main()
{
  int length;
  unordered_set<int> setPos;
  cin >> length;
  for(int i = 0; i < length; ++i)
    if(cin.get() == '*')
      setPos.insert(i);

  for(int i = length/5; i > 0; --i)
  {
    int count = 0;
    for(auto pos : setPos)
      if(setPos.find(pos+i) != setPos.end())
        ++count;
    if(count >= 4)
    {
      cout << "yes";
      return 0;
    }
  }

  cout << "no";
  return 0;
}
